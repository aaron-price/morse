{"version":3,"sources":["app/helpers/parser.cljs"],"mappings":"","names":[],"sourcesContent":["(ns app.helpers.parser\n  (:require\n    [cljs.core.match :refer [match]]\n    [app.db :refer [chart sym-chart]]))\n;\n;(comment\n;  \"\n;  log entry: map of format {:type (:down | :up), :time (epoch ms)}\n;  log:       vector of log entries\n;  inferred-entry: log entry with a keyword value which may or may NOT be true (yet). \n;  inter-symbol-space (:sym): space between dots and dashes within a single character (. sym - within 'A')\n;  inter-char-space (:char): space between dots and dashes of DIFFERENT characters    (. char - between 'E' and 'T')\n;  inter-word-space (:word): space between words. (' ' in 'hello world')\n;  inferred-value: (:. | :- | :sym | :char | :word | :pending) \n;  inflog: log of entries with inferred values\n;  morse-code: vector of inferred value keywords noted above\n;  morse-code-group: vector of keywords (:. | :- | :space). No more pending or inference.\n;  mcg: Alias of morse-code-group \n;  morse-code-groups: list of morse-code-groups. Split by characters. '([:.] [:space] [:. :-] [:- :. :. :.])\n;  morse-text: code-groups using plaintext instead of keywords.  ^ => '(['.'] [' '] ['.' '-'] ['-' '.' '.' '.'])\n;  plain-text-vec: Morse-text, except chars become alphanumeric. ^ => ['E' ' ' 'A' 'B']\n;  plain-text: a string. Plain-text-vec after joining.           ^ => 'E AB'\n;  flat-morse-text: morse-text but all one seq. ['.' ' ' '.' '-']\n;\")\n;\n;(defn infer-value \n;  \"Take two log entries, return the value keyword of the first one.\"\n;  [unit a b]\n;  (if (nil? b) :pending\n;  (let [dot-time #(< % (* 2 unit))\n;        dah-time #(< % (* 4 unit))\n;        {atype :type atime :time} a\n;        {btype :type btime :time} b\n;       ]\n;\n;  (match [(- btime atime) atype btype]\n;         [(t :guard dot-time) :down _] :.\n;         [_                   :down _] :-\n;         [(t :guard dot-time) :up   _] :sym\n;         [(t :guard dah-time) :up   _] :char\n;         [_                   :up   _] :word))))\n;\n;\n;(defn infer-log \n;  \"Take log of entries, add value to each. \n;   Note that it can only look backward in time,\n;     therefore you should finish it with a {:type :tick} to give some future context\"\n;  ([unit log] (infer-log unit log []))\n;  ([unit log acc]\n;  (if (empty? log) acc\n;\n;  (let [[firs secon] log\n;        value (infer-value unit firs secon)\n;        entry (assoc firs :value value)] \n;\n;    (infer-log unit (rest log) (conj acc entry))))))\n;\n;\n;(defn inflog->morse-code \n;  \"Take inflog, return morse-code. \n;   See comments at top of this module for details about both.\"\n;  [inflog]\n;  (reduce\n;    (fn [acc {value :value}]\n;      (cond\n;        (= value :sym) acc\n;        :else          (conj acc value)))\n;    []\n;    inflog))\n;\n;(defn morse-code->mcg [code]\n;  (let [\n;    build (reduce\n;            (fn [{chargroup :chargroup text :text :as acc} sym]\n;              (match sym\n;                     :pending acc ; <- Might need to be something else\n;                     :char {:chargroup [] :text (conj text chargroup)}\n;                     :word {:chargroup [] :text (-> text \n;                                                    (conj chargroup)\n;                                                    (conj [:space]))}\n;                     _     {:chargroup (conj chargroup sym) :text text}))\n;            {:chargroup [] :text []}\n;            code)\n;        \n;    {chg :chargroup txt :text} build\n;  ]\n;    (if (empty? chg)\n;      txt\n;      (conj txt chg))))\n;\n;(defn morse-code-groups->morse-text [groups]\n;  (map\n;    (fn [g]\n;      (match g\n;             [:space] [\" \"]\n;             :else (->> g (map name) vec)))\n;    groups))\n;\n;(defn morse-text->plain-text-vec [morse-text]\n;  (let [ichart (clojure.set/map-invert chart)]\n;    (map\n;      (fn [mt]\n;        (get ichart mt))\n;      morse-text)))\n;\n;(defn log->morse-text [unit log]\n;  (-> (infer-log unit log)\n;        inflog->morse-code\n;        ;morse-code->morse-code-groups\n;        morse-code->mcg\n;        morse-code-groups->morse-text))\n;\n;(defn log->plain-text [unit log]\n;  (-> (infer-log unit log)\n;        inflog->morse-code\n;        ;morse-code->morse-code-groups\n;        morse-code->mcg\n;        morse-code-groups->morse-text\n;        morse-text->plain-text-vec\n;        clojure.string/join))\n;\n;(defn text-vect->sym-vect [text-vect]\n;  (map sym-chart text-vect))\n;\n;(defn sym-vect->morse-text [sym-vect]\n;  (map\n;    (fn [char-vec]\n;      (map name char-vec))\n;    sym-vect))\n;\n;(defn plain-text->sym-vect [text]\n;  (-> text\n;      (clojure.string/split #\"\")\n;      rest ; Leading whitespace for some reason...\n;      vec\n;      text-vect->sym-vect))\n;\n;(defn plain-text->morse-text [plain-text]\n;  (-> plain-text\n;      plain-text->sym-vect\n;      sym-vect->morse-text\n;  ))\n;\n;; @TODO NOW\n;; rewrite this\n;; must have spaces between groups i.e. [ [\".\"] [\"-\"] ]\n;; But must not have trailing, leading, or duplicate spaces.\n;(defn safe-add-space [acc]\n;  (cond\n;    (empty? acc) acc\n;    (= \" \" (last acc)) acc\n;    :else  (concat [\" \"])))\n;\n;(defn strip-last-space [li]\n;  (cond\n;    (= \" \" (last li)) (drop-last li)\n;    :else li))\n;\n;(defn strip-trailing-space [li]\n;  (match (last li)\n;         \" \" (drop-last li)\n;         _   li))\n;\n;(defn strip-dupe-space [li]\n;  (reduce\n;    (fn [acc txt]\n;      (match [acc txt]\n;        [(_ :guard empty?) \" \"] acc\n;        [(_ :guard #(= \" \" (last %))) \" \"] acc\n;        [_  _]   (conj acc txt)))\n;    []\n;    li))\n;\n;(defn li2->li1 [li] (flatten li))\n;\n;(defn morse-text->flat-morse-text \n;  [mt]\n;  (-> mt\n;      li2->li1\n;      strip-dupe-space\n;      ))\n"]}