{"version":3,"sources":["app/helpers/ast.cljs"],"mappings":";AAKA,AAAA,AAAA,AAAKA;AACL,AAAA,AAAA,AAAA,AAAKC;AACL,AAAA,AAAA,AAAA,AAAA,AAAKC;AACL,AAAA,AAAA,AAAA,AAAA,AAAKC;AACL,AAAA,AAAA,AAAA,AAAA,AAAA,AAAKA;AAEL,AAAA,AAAMC,AAAgBC;AAAtB,AACE,AAACC,AACC,AAAAC,AAA4BS;AAA5B,AAAA,AAAAR,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAAA,AAAuBO;AAAvB,AAAAH,AAAAJ,AAAA,AAAaK;AAAb,AAAAD,AAAAJ,AAAA,AAAgBM;AAAhB,AAAA;AADF,AAAA,AAAA,AAAA,AAAA,AAIET","names":["app.helpers.ast/tapstream1","app.helpers.ast/tapstream2","app.helpers.ast/tapstream3","app.helpers.ast/tapstream4","app.helpers.ast/reduced-stream","stream","cljs.core.reduce","p__33239","map__33240","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","li","n","acc","curr"],"sourcesContent":["(ns app.helpers.ast\n  (:require\n    [clojure.core.match :refer [match]]))\n\n\n(def tapstream1 [:tap]) ; a [.]\n(def tapstream2 [:tap :tap]) ; still a [.]\n(def tapstream3 [:tap :tap :tap]) ; now a [-]\n(def tapstream4 [:tap :tap :tap]) ; stil a [-]\n(def tapstream4 [:tap :tap :tap :rest]) ; now a [\"-\" \"/\"]\n\n(defn reduced-stream [stream]\n  (reduce\n    (fn [{:keys [li n] :as acc} curr]\n      \"fuck it\")\n    {:li [] :n 0}\n    stream))\n\n\n; @GOALS\n; Have some readable markup format\n; i.e. [\".\" \"-\" \"/\"]\n;\n; Have an AST\n;\n; Have English text.\n;\n; Then translate from any one format to any other.\n\n; Maybe the capturing stream just builds every tick.\n; No more partials or processing *DURING* ticks\n; Every tick, record either a \"tap\" or \"pause\"\n; you hold for 3 ticks and pause 2 =\n; [\"tap\" \"tap \"tap\" \"pause\" \"pause\"]\n; \n; which is reduced into \n; [{:type \"tap\" :duration 3}\n;  {:type \"pause\" :duration 2}]\n\n; and then\n; [{:type \"tap\" :duration 3 :value \"-\"}\n;  {:type \"pause\" :duration 2 :value \"inter-char\"}]\n\n; So the char ended, but not the word...and thennn....\n\"[\n  {:type 'partial_word'\n   :text 'T'\n   :body [\n    {:type 'tap' :duration 3 :value '-'}\n    {:type 'pause' :duration 2 :value 'inter-char'}\n   ]\n  }\n]\n\n@TODO\nThat exact syntax probably won't work. Workshop it a touch.\n\nYou should be able to have that ast build out with every tick.\nAnd when you aren't finished yet, you won't have a text field.\nThat should be saved for :type 'complete_word'\n\"\n"]}