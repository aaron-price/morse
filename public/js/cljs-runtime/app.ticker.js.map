{"version":3,"sources":["app/ticker.cljs"],"mappings":"","names":[],"sourcesContent":["(ns app.ticker\n  (:require\n    [re-frame.core :refer [dispatch subscribe reg-event-db reg-event-fx]]\n    [cljs.core.async :refer [chan >! <! timeout]]\n    [cljs.core.async :refer-macros [go]]\n    ;[app.helpers.parser :refer [log->morse-text]]\n  ))\n\n;(def ticker-chan (chan))\n;(def ticker-online (atom true))\n;(defn start-ticker [] (reset! ticker-online true))\n;(defn stop-ticker [] (reset! ticker-online false))\n\n;(defn tick []\n;  (let [online (atom true)\n;        c (chan)]\n;    (go (while @online\n;          (>! c \"Tick\")\n;          (prn (<! c))\n;          (dispatch [:inc-score])\n;          (timeout 250)))))\n;\n;(comment\n;(tick)\n;)\n;\n;; Do not put the ticker in re-frame.\n;; Although it does work, it breaks re-frame-10x for unknown reasons.\n;; Instead I think the 'correct' way is to have js/window manage it\n;; and every tick might dispatch a tick, passing in its data.\n;\n;\n;(defn update-morse-text [{:keys [log unit] :as db}]\n;\n;  (let [tick-entry {:time (.now js/Date) ;(+ unit (.now js/Date))\n;                    :type :tick}\n;        tick-log (conj log tick-entry)\n;        new-text (log->morse-text unit tick-log)]\n;    (assoc db :morse-text-log new-text)))\n;\n;(defn grr []\n;  (prn \"FUCKITY FUCK\"))\n;\n;(defn start-ticker []\n;  (. js/window (spawn_ticker #(prn \"DO IT NOW\") 500)))\n;  ;(. js/window (spawn_ticker #(dispatch [:inc-score]) 500)))\n;(defn stop-ticker []\n;  (. js/window clear_ticker))\n;;\n;;(reg-event-fx\n;;  :start-ticker\n;;  (fn []\n;;    {:dispatch-interval {:dispatch [:tick]\n;;                         :id :dispatch-ticker\n;;                         :ms 30}}))\n;;(reg-event-db\n;;  :start-ticker\n;;  (fn [{db :db} _] ;{:keys [unit ticker] :as db} _]\n;;    (if (nil? (get-in db [:ticker :interval]))\n;;      (let [interval (js/setInterval #(dispatch [:tick]) 30)\n;;            db (assoc-in db [:ticker :interval] (:interval db))]\n;;        {:db db})\n;;      {:db db})))\n;\n;\n;(reg-event-fx\n;  :stop-ticker\n;  (fn []\n;    {:clear-interval {:id :dispatch-ticker}}))\n;\n;;(reg-event-db\n;;  :stop-ticker\n;;  ;(fn [{:keys [ticker] :as db} _]\n;;  (fn [{db :db} _]\n;;    (let [interval (get-in db [:ticker :interval])]\n;;      (if-not (nil? interval) (js/clearInterval interval))\n;;      {:db (assoc-in db [:ticker interval] nil)})))\n;\n;\n;(defn reset-stale [db] (assoc db :tick-stale 0))\n;(defn inc-stale [{:keys [tick-stale] :as db}] \n;  (assoc db :tick-stale 0))\n;\n;(defn inc-tick [db]\n;  (let [tick-count (or (:tick-count db) 0)\n;        new-count (inc tick-count)\n;        stale-count (or (:tick-stale db) 0)\n;        new-stale (inc stale-count)]\n;    (-> db\n;        (assoc :tick-count new-count)\n;        (assoc :tick-stale new-stale))))\n;\n;(reg-event-fx \n;  :tick\n;  (fn [{db :db} _]\n;    {:db (-> db\n;             update-morse-text\n;             inc-tick)}))\n"]}